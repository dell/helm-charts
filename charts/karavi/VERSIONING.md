
# Versioning <!-- omit in toc -->
## Table of Content <!-- omit in toc -->
- [Versioning Strategy](#versioning-strategy)
  - [Major releases](#major-releases)
  - [Minor releases](#minor-releases)
  - [Patch releases](#patch-releases)
  - [Preleases](#preleases)
    - [References](#references)
- [Versioning Workflow](#versioning-workflow)
  - [Consume New Release](#consume-new-release)

## Versioning Strategy
This versioning strategy applies to Dell Helm Charts.

Artifacts published must belong to one of the following categories:
  * "Releases", i.e. artifacts that have versions that follow the `x.y.z` format,
    where `x` is called "major version", `y` is called "minor version"
    and `z` is called "patch version".
  * "Prereleases", i.e. artifacts that have versions that follow the `x.y.z-suffix` format,
    where `x`, `y` and `z` are called the same as above, and `suffix` is
    an arbitrary suffix created by a human or generated by a tool.

### Major releases

"Major releases" are artifacts published as `x.0.0`:
  * An artifact must be released as `x.0.0` if and only if
    the difference between the current code and the code that
    has been published as `{x-1}.0.0`contains changes to:
    - Any changes that change the behaviour of existing infrastructure
    - Any changes that prevents you to deploy over and existing stack
    - Any CLI command being removed or changed
    - `{x+1}.0.0` is strongly encouraged to be backward compatible with `x.y.z` modulo deprecation warnings:
        * It is desirable to compilable against `x.y.z` to be compilable against `{x+1}.0.0` modulo deprecation warnings.
        * It is desirable to linkable against `x.y.z` to be linkable with `{x+1}.0.0`.

 
### Minor releases

"Minor releases" are artifacts published as `x.y.0`:
  * An artifact must be released as `x.y.0` if and only if
    the difference between the current code and the code
    that has been published as `x.0.0`, changes to `x.{y+1}.0` must be backward compatible with `x.y.0`:
    * It is desirable to compilable against `x.y.0` must be compilable against `x.{y+1}.z` without deprecation warnings.
    * It is desirable to linkable against `x.y.0` must be linkable against `x.{y+1}.z`.

### Patch releases

"Patch releases" are artifacts published as `x.y.z`:
  * An artifact must be released as `x.y.z` if and only if
    the difference between the current code and the code
    that has been published as `x.y.0`.
  * A release only containing backwards-compatible bug fixes.

### Preleases

"Prereleases" are artifacts published as `x.y.z-suffix`:
  * An artifact may be published as `x.y.z-suffix` if and only if:
      1) There exists an `x.y.z` release, and
      2) There exist neither `{x+1}.0.0`, nor `x.{y+1}.0`, nor `x.y.{z+1}` releases.
      3) `suffix` is in compliance with [semantic versioning](https://semver.org/).
      4) `suffix` does not equal `SNAPSHOT`.

#### References
Dell Helm Charts follow Semantic Versioning as defined on [http://semver.org/](http://semver.org).

## Versioning Workflow
This versioning workflow applies to the Karavi Helm Chart. This workflow is triggered either when there is a change to the Karavi Helm Chart or when there is a new release of any of the child Karavi Helm Charts. When either scenario occurs, a maintainer must release a new helm chart for that associated change. The steps include:

1) [Create a branch](../../CONTRIBUTING.md)
2) Update the [Chart.yaml](../karavi/Chart.yaml) file, depending on the scenario that triggered this workflow. These scenarios include:
   - **Change to the Karavi Helm Chart:**
     If any changes are made in Karavi Helm Chart, for instance when the [values.yaml](../karavi/values.yaml) file is modified, the Karavi Helm Chart version number must be change according to the [Versioning Strategy](#versioning-strategy). For instance, consider the current Chart.yaml below: 
     ```yaml
      apiVersion: v2
      name: karavi
      description: A Helm chart for Kubernetes
      type: application
      version: 0.1.0
      dependencies:
      - name: karavi-topology
        version: "0.1.0"
        repository: "file://../karavi-topology"
        condition: karavi-topology.enabled
      - name: karavi-powerflex-metrics
        version: "0.1.0"
        repository: "file://../karavi-powerflex-metrics"
        condition: karavi-powerflex-metrics.enabled
     ```
     If after reviewing the versioning strategy, the maintainer concludes that the new version of the Karavi Helm Chart should be `0.2.0`, Chart.yaml becomes:
     ```yaml
      apiVersion: v2
      name: karavi
      description: A Helm chart for Kubernetes
      type: application
      version: 0.2.0 # version updates to 0.2.0 
      dependencies:
      - name: karavi-topology
        version: "0.1.0"
        repository: "file://../karavi-topology"
        condition: karavi-topology.enabled
      - name: karavi-powerflex-metrics
        version: "1.1.0"
        repository: "file://../karavi-powerflex-metrics"
        condition: karavi-powerflex-metrics.enabled
     ```     
   - **New Release of any of the child Karavi Helm Chart:**
     When there is a new release of any child Karavi Helm Chart, for instance when a new Karavi Powerflex Metrics version: `1.2.0` is released, the maintainer should first update the Karavi Helm Chart version number according to the [Versioning Strategy](#versioning-strategy). Secondly, the dependency on the specific child helm chart that has a new release must be updated as well. In our example, the Karavi Powerflex Metrics has a new release of version `1.2.0`. Before any update, the Chart.yaml may look like this: 
     ```yaml
      apiVersion: v2
      name: karavi
      description: A Helm chart for Kubernetes
      type: application
      version: 0.1.0 
      dependencies:
      - name: karavi-topology
        version: "0.1.0"
        repository: "file://../karavi-topology"
        condition: karavi-topology.enabled
      - name: karavi-powerflex-metrics
        version: "1.1.0"
        repository: "file://../karavi-powerflex-metrics"
        condition: karavi-powerflex-metrics.enabled
     ```
     If after reviewing the versioning strategy,  the maintainer concludes that the new version of the Karavi Helm Chart should be `0.2.0`, Chart.yaml becomes:
     ```yaml
      apiVersion: v2
      name: karavi
      description: A Helm chart for Kubernetes
      type: application
      version: 0.2.0 # version updates to 0.2.0
      dependencies:
      - name: karavi-topology
        version: "0.1.0"
        repository: "file://../karavi-topology"
        condition: karavi-topology.enabled
      - name: karavi-powerflex-metrics
        version: "1.2.0" # version updates to 1.2.0
        repository: "file://../karavi-powerflex-metrics"
        condition: karavi-powerflex-metrics.enabled
     ```
3) Create and merge PR into main branch
4) Github action will automatically make a new release given that there is a new chart version. The action packages and publishes an artifact,  making it available for consumption. Given the example above, in either scenerio, the GitHub action will produce a release called `karavi-0.2.0`.

### Consume New Release
* Given the example above, users can utilize the new release by running the following commands:
```bash
   helm repo add dell https://github.com/dell/helm-charts
   helm install karavi --version "0.2.0" -n karavi --create-namespace --render-subchart-notes
   ```