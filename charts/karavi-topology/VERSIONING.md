# Versioning <!-- omit in toc -->
## Table of Contents <!-- omit in toc -->
- [Versioning Strategy](#versioning-strategy)
  - [Major releases](#major-releases)
  - [Minor releases](#minor-releases)
  - [Patch releases](#patch-releases)
  - [Preleases](#preleases)
    - [References](#references)
- [Versioning Workflow](#versioning-workflow)
  - [Consume New Release](#consume-new-release)

## Versioning Strategy
This versioning strategy applies to Dell Helm Charts.

Artifacts published must belong to one of the following categories:
  * "Releases", i.e. artifacts that have versions that follow the `x.y.z` format,
    where `x` is called "major version", `y` is called "minor version"
    and `z` is called "patch version".
  * "Prereleases", i.e. artifacts that have versions that follow the `x.y.z-suffix` format,
    where `x`, `y` and `z` are called the same as above, and `suffix` is
    an arbitrary suffix created by a human or generated by a tool.

### Major releases

"Major releases" are artifacts published as `x.0.0`:
  * An artifact must be released as `x.0.0` if and only if
    the difference between the current code and the code that
    has been published as `{x-1}.0.0`contains changes to:
    - Any changes that change the behaviour of existing infrastructure
    - Any changes that prevents you to deploy over and existing stack
    - Any CLI command being removed or changed
    - `{x+1}.0.0` is strongly encouraged to be backward compatible with `x.y.z` modulo deprecation warnings:
        * It is desirable to compilable against `x.y.z` to be compilable against `{x+1}.0.0` modulo deprecation warnings.
        * It is desirable to linkable against `x.y.z` to be linkable with `{x+1}.0.0`.

 
### Minor releases

"Minor releases" are artifacts published as `x.y.0`:
  * An artifact must be released as `x.y.0` if and only if
    the difference between the current code and the code
    that has been published as `x.0.0`, changes to `x.{y+1}.0` must be backward compatible with `x.y.0`:
    * It is desirable to compilable against `x.y.0` must be compilable against `x.{y+1}.z` without deprecation warnings.
    * It is desirable to linkable against `x.y.0` must be linkable against `x.{y+1}.z`.

### Patch releases

"Patch releases" are artifacts published as `x.y.z`:
  * An artifact must be released as `x.y.z` if and only if
    the difference between the current code and the code
    that has been published as `x.y.0`.
  * A release only containing backwards-compatible bug fixes.

### Preleases

"Prereleases" are artifacts published as `x.y.z-suffix`:
  * An artifact may be published as `x.y.z-suffix` if and only if:
      1) There exists an `x.y.z` release, and
      2) There exist neither `{x+1}.0.0`, nor `x.{y+1}.0`, nor `x.y.{z+1}` releases.
      3) `suffix` is in compliance with [semantic versioning](https://semver.org/).
      4) `suffix` does not equal `SNAPSHOT`.

#### References
Dell Helm Charts follow Semantic Versioning as defined on [http://semver.org/](http://semver.org).

## Versioning Workflow
This versioning workflow applies to the Karavi Topology Helm Chart. This workflow is triggered when there is a new release of [karavi-topology](https://github.com/dell/karavi-topology) or when there is a change made to the Karavi Topology Topology Helm Chart. When either scenario occurs, a maintainer must release a new helm chart for that associated change. The steps include:
1) [Create a branch](../../CONTRIBUTING.md)
2) Update the [Chart.yaml](../karavi-topology/Chart.yaml) file, depending on the scenario that triggered this workflow. These scenarios include:
   - **Change to the Karavi Topology Helm Chart:**
     If any changes are made in the Karavi Topology Chart, for instance when the [values.yaml](../karavi-topology/values.yaml) file is modified, the Karavi Topology Chart version number must be changed according to the [Versioning Strategy](#versioning-strategy). For instance, consider the current Chart.yaml below: 
     ```yaml
        apiVersion: v1
        appVersion: "1.0"
        description: The open-source solution that provides Kubernetes administrators insight into storage usage and performance for containerized applications using Dell products.
        name: karavi-topology
        version: 0.1.0
     ```
     If after reviewing the versioning strategy, the maintainer concludes that the new version of the Karavi Topology Chart should be `0.2.0`, Chart.yaml becomes:
     ```yaml
        apiVersion: v1
        appVersion: "1.0"
        description: The open-source solution that provides Kubernetes administrators insight into storage usage and performance for containerized applications using Dell products.
        name: karavi-topology
        version: 0.2.0 # updated to 0.2.0
     ```     
   - **New Release of [Karavi Topology](https://github.com/dell/karavi-topology) Service:**
     When there is a new release of Karavi Topology, for instance when a new Karavi Topology service of version: `1.2.0` is released, the maintainer should first update the Karavi Helm Chart version number according to the [Versioning Strategy](#versioning-strategy). Secondly, the `appVersion` MUST be updated to match the new Karavi Topology service release. In our example, the Karavi Topology service has a new release of version `1.2.0`. Before any update, the Chart.yaml may look like this: 
     ```yaml
        apiVersion: v1
        appVersion: "1.0"
        description: The open-source solution that provides Kubernetes administrators insight into storage usage and performance for containerized applications using Dell products.
        name: karavi-topology
        version: 0.1.0
     ```
     If after reviewing the versioning strategy,  the maintainer concludes that the new version of the Karavi Topology Helm Chart should be `0.2.0`, Chart.yaml becomes:
     ```yaml
        apiVersion: v1
        appVersion: "1.2.0" # updated to 1.2.0 to match the new service released
        description: The open-source solution that provides Kubernetes administrators insight into storage usage and performance for containerized applications using Dell products.
        name: karavi-topology
        version: 0.2.0 # updated to 0.2.0
     ```
3) Create and merge PR into main branch
4) Github action will automatically make a new release given that there is a new chart version. The action packages and publishes an artifact,  making it available for consumption. Given the example above, in either scenerio, the GitHub action will produce a release called `karavi-topology-0.2.0`.

### Consume New Release
* Given the example above, users can utilize the new release by running the following commands:
```bash
   helm repo add dell https://github.com/dell/helm-charts
   helm install karavi-topology --version "0.2.0" -n karavi --create-namespace

   ```